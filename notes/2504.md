今天的题目思路很清楚，但是操作上在繁琐的数组index boundary check上花了很多时间
最后面对越来越大的代码块，重心已经偏移，思路反而不清楚了，以至于到part2的时候，只更新了count,直接就忘记了要更新input，进入了死循环
然后此时的代码也臃肿不已，内心已经panic无法冷静思考了。 于是放弃直接问了AI.

被ai的clean code惊到了，这就是很直接的对于我解题思路的白描。
底层的数组操作被抽象到子函数了，这样在main‘上看解题思路非常清楚，

回忆其自顶向下的mindset，和一些专业选手都使用自己的库
我打算之后的题目也是像aicode 一样，先默认有了saft add/desrc 之后， 不先深入考虑细节，现在solution上写清楚要做到事情，然后明细再用ai生成。 

首先在part1 的时候，最终除了检查count还需要检查 cur char为@才能res++ 的时候，
我发现不能再遍历外访问char，此时就应该警惕需要维护一个 char grid 了，但是那个时候想要“一次” iter就结束，不想要重复iter去搞定iter
这种mindset是不对的，让我走上了错误的道路

这种一开始，solution还没有出来  就想要optimize的思维是非常糟糕的，
回过头看，有了part2 目前ai生成的solution，这时候再思考哪里可以少一些iter会更好，
而不是做到一半，就去想这些，这占用了我无意识的算力，然后面对臃肿的 bourdary check迷失了思路

更何况，仔细思考后发现，这操作只是多了 1 次迭代 而不是 n此，不对数据规模归档而增长，也没有太大优化的必要